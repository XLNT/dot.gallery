type AggregateAsset {
  count: Int!
}

type AggregateEntity {
  count: Int!
}

type AggregateExhibition {
  count: Int!
}

type AggregateIssue {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateShow {
  count: Int!
}

type Asset {
  id: ID!
  isCounterfactual: Boolean!
  owner: Entity!
  issue: Issue!
  printer: Entity!
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssetConnection {
  pageInfo: PageInfo!
  edges: [AssetEdge]!
  aggregate: AggregateAsset!
}

input AssetCreateInput {
  id: ID
  isCounterfactual: Boolean
  owner: EntityCreateOneWithoutOwnedAssetsInput!
  issue: IssueCreateOneWithoutAssetsInput!
  printer: EntityCreateOneWithoutPrintedAssetsInput!
  rooms: RoomCreateManyWithoutAssetsInput
}

input AssetCreateManyWithoutIssueInput {
  create: [AssetCreateWithoutIssueInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateManyWithoutOwnerInput {
  create: [AssetCreateWithoutOwnerInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateManyWithoutPrinterInput {
  create: [AssetCreateWithoutPrinterInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateManyWithoutRoomsInput {
  create: [AssetCreateWithoutRoomsInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateWithoutIssueInput {
  id: ID
  isCounterfactual: Boolean
  owner: EntityCreateOneWithoutOwnedAssetsInput!
  printer: EntityCreateOneWithoutPrintedAssetsInput!
  rooms: RoomCreateManyWithoutAssetsInput
}

input AssetCreateWithoutOwnerInput {
  id: ID
  isCounterfactual: Boolean
  issue: IssueCreateOneWithoutAssetsInput!
  printer: EntityCreateOneWithoutPrintedAssetsInput!
  rooms: RoomCreateManyWithoutAssetsInput
}

input AssetCreateWithoutPrinterInput {
  id: ID
  isCounterfactual: Boolean
  owner: EntityCreateOneWithoutOwnedAssetsInput!
  issue: IssueCreateOneWithoutAssetsInput!
  rooms: RoomCreateManyWithoutAssetsInput
}

input AssetCreateWithoutRoomsInput {
  id: ID
  isCounterfactual: Boolean
  owner: EntityCreateOneWithoutOwnedAssetsInput!
  issue: IssueCreateOneWithoutAssetsInput!
  printer: EntityCreateOneWithoutPrintedAssetsInput!
}

type AssetEdge {
  node: Asset!
  cursor: String!
}

enum AssetOrderByInput {
  id_ASC
  id_DESC
  isCounterfactual_ASC
  isCounterfactual_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AssetPreviousValues {
  id: ID!
  isCounterfactual: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AssetScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isCounterfactual: Boolean
  isCounterfactual_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  NOT: [AssetScalarWhereInput!]
}

type AssetSubscriptionPayload {
  mutation: MutationType!
  node: Asset
  updatedFields: [String!]
  previousValues: AssetPreviousValues
}

input AssetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AssetWhereInput
  AND: [AssetSubscriptionWhereInput!]
  OR: [AssetSubscriptionWhereInput!]
  NOT: [AssetSubscriptionWhereInput!]
}

input AssetUpdateInput {
  isCounterfactual: Boolean
  owner: EntityUpdateOneRequiredWithoutOwnedAssetsInput
  issue: IssueUpdateOneRequiredWithoutAssetsInput
  printer: EntityUpdateOneRequiredWithoutPrintedAssetsInput
  rooms: RoomUpdateManyWithoutAssetsInput
}

input AssetUpdateManyDataInput {
  isCounterfactual: Boolean
}

input AssetUpdateManyMutationInput {
  isCounterfactual: Boolean
}

input AssetUpdateManyWithoutIssueInput {
  create: [AssetCreateWithoutIssueInput!]
  delete: [AssetWhereUniqueInput!]
  connect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutIssueInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutIssueInput!]
  deleteMany: [AssetScalarWhereInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
}

input AssetUpdateManyWithoutOwnerInput {
  create: [AssetCreateWithoutOwnerInput!]
  delete: [AssetWhereUniqueInput!]
  connect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [AssetScalarWhereInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
}

input AssetUpdateManyWithoutPrinterInput {
  create: [AssetCreateWithoutPrinterInput!]
  delete: [AssetWhereUniqueInput!]
  connect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutPrinterInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutPrinterInput!]
  deleteMany: [AssetScalarWhereInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
}

input AssetUpdateManyWithoutRoomsInput {
  create: [AssetCreateWithoutRoomsInput!]
  delete: [AssetWhereUniqueInput!]
  connect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutRoomsInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutRoomsInput!]
  deleteMany: [AssetScalarWhereInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
}

input AssetUpdateManyWithWhereNestedInput {
  where: AssetScalarWhereInput!
  data: AssetUpdateManyDataInput!
}

input AssetUpdateWithoutIssueDataInput {
  isCounterfactual: Boolean
  owner: EntityUpdateOneRequiredWithoutOwnedAssetsInput
  printer: EntityUpdateOneRequiredWithoutPrintedAssetsInput
  rooms: RoomUpdateManyWithoutAssetsInput
}

input AssetUpdateWithoutOwnerDataInput {
  isCounterfactual: Boolean
  issue: IssueUpdateOneRequiredWithoutAssetsInput
  printer: EntityUpdateOneRequiredWithoutPrintedAssetsInput
  rooms: RoomUpdateManyWithoutAssetsInput
}

input AssetUpdateWithoutPrinterDataInput {
  isCounterfactual: Boolean
  owner: EntityUpdateOneRequiredWithoutOwnedAssetsInput
  issue: IssueUpdateOneRequiredWithoutAssetsInput
  rooms: RoomUpdateManyWithoutAssetsInput
}

input AssetUpdateWithoutRoomsDataInput {
  isCounterfactual: Boolean
  owner: EntityUpdateOneRequiredWithoutOwnedAssetsInput
  issue: IssueUpdateOneRequiredWithoutAssetsInput
  printer: EntityUpdateOneRequiredWithoutPrintedAssetsInput
}

input AssetUpdateWithWhereUniqueWithoutIssueInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateWithoutIssueDataInput!
}

input AssetUpdateWithWhereUniqueWithoutOwnerInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateWithoutOwnerDataInput!
}

input AssetUpdateWithWhereUniqueWithoutPrinterInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateWithoutPrinterDataInput!
}

input AssetUpdateWithWhereUniqueWithoutRoomsInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateWithoutRoomsDataInput!
}

input AssetUpsertWithWhereUniqueWithoutIssueInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateWithoutIssueDataInput!
  create: AssetCreateWithoutIssueInput!
}

input AssetUpsertWithWhereUniqueWithoutOwnerInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateWithoutOwnerDataInput!
  create: AssetCreateWithoutOwnerInput!
}

input AssetUpsertWithWhereUniqueWithoutPrinterInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateWithoutPrinterDataInput!
  create: AssetCreateWithoutPrinterInput!
}

input AssetUpsertWithWhereUniqueWithoutRoomsInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateWithoutRoomsDataInput!
  create: AssetCreateWithoutRoomsInput!
}

input AssetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isCounterfactual: Boolean
  isCounterfactual_not: Boolean
  owner: EntityWhereInput
  issue: IssueWhereInput
  printer: EntityWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  NOT: [AssetWhereInput!]
}

input AssetWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Entity {
  id: ID!
  handle: String!
  email: String!
  createdIssues(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Issue!]
  ownedAssets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
  printedAssets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]!
  aggregate: AggregateEntity!
}

input EntityCreateInput {
  id: ID
  handle: String!
  email: String!
  createdIssues: IssueCreateManyWithoutCreatorInput
  ownedAssets: AssetCreateManyWithoutOwnerInput
  printedAssets: AssetCreateManyWithoutPrinterInput
}

input EntityCreateOneWithoutCreatedIssuesInput {
  create: EntityCreateWithoutCreatedIssuesInput
  connect: EntityWhereUniqueInput
}

input EntityCreateOneWithoutOwnedAssetsInput {
  create: EntityCreateWithoutOwnedAssetsInput
  connect: EntityWhereUniqueInput
}

input EntityCreateOneWithoutPrintedAssetsInput {
  create: EntityCreateWithoutPrintedAssetsInput
  connect: EntityWhereUniqueInput
}

input EntityCreateWithoutCreatedIssuesInput {
  id: ID
  handle: String!
  email: String!
  ownedAssets: AssetCreateManyWithoutOwnerInput
  printedAssets: AssetCreateManyWithoutPrinterInput
}

input EntityCreateWithoutOwnedAssetsInput {
  id: ID
  handle: String!
  email: String!
  createdIssues: IssueCreateManyWithoutCreatorInput
  printedAssets: AssetCreateManyWithoutPrinterInput
}

input EntityCreateWithoutPrintedAssetsInput {
  id: ID
  handle: String!
  email: String!
  createdIssues: IssueCreateManyWithoutCreatorInput
  ownedAssets: AssetCreateManyWithoutOwnerInput
}

type EntityEdge {
  node: Entity!
  cursor: String!
}

enum EntityOrderByInput {
  id_ASC
  id_DESC
  handle_ASC
  handle_DESC
  email_ASC
  email_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EntityPreviousValues {
  id: ID!
  handle: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EntitySubscriptionPayload {
  mutation: MutationType!
  node: Entity
  updatedFields: [String!]
  previousValues: EntityPreviousValues
}

input EntitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EntityWhereInput
  AND: [EntitySubscriptionWhereInput!]
  OR: [EntitySubscriptionWhereInput!]
  NOT: [EntitySubscriptionWhereInput!]
}

input EntityUpdateInput {
  handle: String
  email: String
  createdIssues: IssueUpdateManyWithoutCreatorInput
  ownedAssets: AssetUpdateManyWithoutOwnerInput
  printedAssets: AssetUpdateManyWithoutPrinterInput
}

input EntityUpdateManyMutationInput {
  handle: String
  email: String
}

input EntityUpdateOneRequiredWithoutCreatedIssuesInput {
  create: EntityCreateWithoutCreatedIssuesInput
  update: EntityUpdateWithoutCreatedIssuesDataInput
  upsert: EntityUpsertWithoutCreatedIssuesInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateOneRequiredWithoutOwnedAssetsInput {
  create: EntityCreateWithoutOwnedAssetsInput
  update: EntityUpdateWithoutOwnedAssetsDataInput
  upsert: EntityUpsertWithoutOwnedAssetsInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateOneRequiredWithoutPrintedAssetsInput {
  create: EntityCreateWithoutPrintedAssetsInput
  update: EntityUpdateWithoutPrintedAssetsDataInput
  upsert: EntityUpsertWithoutPrintedAssetsInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateWithoutCreatedIssuesDataInput {
  handle: String
  email: String
  ownedAssets: AssetUpdateManyWithoutOwnerInput
  printedAssets: AssetUpdateManyWithoutPrinterInput
}

input EntityUpdateWithoutOwnedAssetsDataInput {
  handle: String
  email: String
  createdIssues: IssueUpdateManyWithoutCreatorInput
  printedAssets: AssetUpdateManyWithoutPrinterInput
}

input EntityUpdateWithoutPrintedAssetsDataInput {
  handle: String
  email: String
  createdIssues: IssueUpdateManyWithoutCreatorInput
  ownedAssets: AssetUpdateManyWithoutOwnerInput
}

input EntityUpsertWithoutCreatedIssuesInput {
  update: EntityUpdateWithoutCreatedIssuesDataInput!
  create: EntityCreateWithoutCreatedIssuesInput!
}

input EntityUpsertWithoutOwnedAssetsInput {
  update: EntityUpdateWithoutOwnedAssetsDataInput!
  create: EntityCreateWithoutOwnedAssetsInput!
}

input EntityUpsertWithoutPrintedAssetsInput {
  update: EntityUpdateWithoutPrintedAssetsDataInput!
  create: EntityCreateWithoutPrintedAssetsInput!
}

input EntityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  createdIssues_every: IssueWhereInput
  createdIssues_some: IssueWhereInput
  createdIssues_none: IssueWhereInput
  ownedAssets_every: AssetWhereInput
  ownedAssets_some: AssetWhereInput
  ownedAssets_none: AssetWhereInput
  printedAssets_every: AssetWhereInput
  printedAssets_some: AssetWhereInput
  printedAssets_none: AssetWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EntityWhereInput!]
  OR: [EntityWhereInput!]
  NOT: [EntityWhereInput!]
}

input EntityWhereUniqueInput {
  id: ID
  handle: String
  email: String
}

type Exhibition {
  id: ID!
  number: Int!
  theme: Json
  extent: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  shows(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show!]
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExhibitionConnection {
  pageInfo: PageInfo!
  edges: [ExhibitionEdge]!
  aggregate: AggregateExhibition!
}

input ExhibitionCreateInput {
  id: ID
  number: Int!
  theme: Json
  extent: Int
  opensAt: DateTime!
  closesAt: DateTime!
  shows: ShowCreateManyWithoutExhibitionInput
  rooms: RoomCreateManyWithoutExhibitionInput
}

input ExhibitionCreateOneWithoutRoomsInput {
  create: ExhibitionCreateWithoutRoomsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionCreateOneWithoutShowsInput {
  create: ExhibitionCreateWithoutShowsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionCreateWithoutRoomsInput {
  id: ID
  number: Int!
  theme: Json
  extent: Int
  opensAt: DateTime!
  closesAt: DateTime!
  shows: ShowCreateManyWithoutExhibitionInput
}

input ExhibitionCreateWithoutShowsInput {
  id: ID
  number: Int!
  theme: Json
  extent: Int
  opensAt: DateTime!
  closesAt: DateTime!
  rooms: RoomCreateManyWithoutExhibitionInput
}

type ExhibitionEdge {
  node: Exhibition!
  cursor: String!
}

enum ExhibitionOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  theme_ASC
  theme_DESC
  extent_ASC
  extent_DESC
  opensAt_ASC
  opensAt_DESC
  closesAt_ASC
  closesAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExhibitionPreviousValues {
  id: ID!
  number: Int!
  theme: Json
  extent: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExhibitionSubscriptionPayload {
  mutation: MutationType!
  node: Exhibition
  updatedFields: [String!]
  previousValues: ExhibitionPreviousValues
}

input ExhibitionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExhibitionWhereInput
  AND: [ExhibitionSubscriptionWhereInput!]
  OR: [ExhibitionSubscriptionWhereInput!]
  NOT: [ExhibitionSubscriptionWhereInput!]
}

input ExhibitionUpdateInput {
  number: Int
  theme: Json
  extent: Int
  opensAt: DateTime
  closesAt: DateTime
  shows: ShowUpdateManyWithoutExhibitionInput
  rooms: RoomUpdateManyWithoutExhibitionInput
}

input ExhibitionUpdateManyMutationInput {
  number: Int
  theme: Json
  extent: Int
  opensAt: DateTime
  closesAt: DateTime
}

input ExhibitionUpdateOneRequiredWithoutRoomsInput {
  create: ExhibitionCreateWithoutRoomsInput
  update: ExhibitionUpdateWithoutRoomsDataInput
  upsert: ExhibitionUpsertWithoutRoomsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionUpdateOneRequiredWithoutShowsInput {
  create: ExhibitionCreateWithoutShowsInput
  update: ExhibitionUpdateWithoutShowsDataInput
  upsert: ExhibitionUpsertWithoutShowsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionUpdateWithoutRoomsDataInput {
  number: Int
  theme: Json
  extent: Int
  opensAt: DateTime
  closesAt: DateTime
  shows: ShowUpdateManyWithoutExhibitionInput
}

input ExhibitionUpdateWithoutShowsDataInput {
  number: Int
  theme: Json
  extent: Int
  opensAt: DateTime
  closesAt: DateTime
  rooms: RoomUpdateManyWithoutExhibitionInput
}

input ExhibitionUpsertWithoutRoomsInput {
  update: ExhibitionUpdateWithoutRoomsDataInput!
  create: ExhibitionCreateWithoutRoomsInput!
}

input ExhibitionUpsertWithoutShowsInput {
  update: ExhibitionUpdateWithoutShowsDataInput!
  create: ExhibitionCreateWithoutShowsInput!
}

input ExhibitionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  extent: Int
  extent_not: Int
  extent_in: [Int!]
  extent_not_in: [Int!]
  extent_lt: Int
  extent_lte: Int
  extent_gt: Int
  extent_gte: Int
  opensAt: DateTime
  opensAt_not: DateTime
  opensAt_in: [DateTime!]
  opensAt_not_in: [DateTime!]
  opensAt_lt: DateTime
  opensAt_lte: DateTime
  opensAt_gt: DateTime
  opensAt_gte: DateTime
  closesAt: DateTime
  closesAt_not: DateTime
  closesAt_in: [DateTime!]
  closesAt_not_in: [DateTime!]
  closesAt_lt: DateTime
  closesAt_lte: DateTime
  closesAt_gt: DateTime
  closesAt_gte: DateTime
  shows_every: ShowWhereInput
  shows_some: ShowWhereInput
  shows_none: ShowWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExhibitionWhereInput!]
  OR: [ExhibitionWhereInput!]
  NOT: [ExhibitionWhereInput!]
}

input ExhibitionWhereUniqueInput {
  id: ID
  number: Int
}

type Issue {
  id: ID!
  uri: String!
  rarity: Rarity!
  emojis: [String!]!
  creator: Entity!
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type IssueConnection {
  pageInfo: PageInfo!
  edges: [IssueEdge]!
  aggregate: AggregateIssue!
}

input IssueCreateemojisInput {
  set: [String!]
}

input IssueCreateInput {
  id: ID
  uri: String!
  rarity: Rarity
  emojis: IssueCreateemojisInput
  creator: EntityCreateOneWithoutCreatedIssuesInput!
  assets: AssetCreateManyWithoutIssueInput
}

input IssueCreateManyWithoutCreatorInput {
  create: [IssueCreateWithoutCreatorInput!]
  connect: [IssueWhereUniqueInput!]
}

input IssueCreateOneWithoutAssetsInput {
  create: IssueCreateWithoutAssetsInput
  connect: IssueWhereUniqueInput
}

input IssueCreateWithoutAssetsInput {
  id: ID
  uri: String!
  rarity: Rarity
  emojis: IssueCreateemojisInput
  creator: EntityCreateOneWithoutCreatedIssuesInput!
}

input IssueCreateWithoutCreatorInput {
  id: ID
  uri: String!
  rarity: Rarity
  emojis: IssueCreateemojisInput
  assets: AssetCreateManyWithoutIssueInput
}

type IssueEdge {
  node: Issue!
  cursor: String!
}

enum IssueOrderByInput {
  id_ASC
  id_DESC
  uri_ASC
  uri_DESC
  rarity_ASC
  rarity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type IssuePreviousValues {
  id: ID!
  uri: String!
  rarity: Rarity!
  emojis: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input IssueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  rarity: Rarity
  rarity_not: Rarity
  rarity_in: [Rarity!]
  rarity_not_in: [Rarity!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [IssueScalarWhereInput!]
  OR: [IssueScalarWhereInput!]
  NOT: [IssueScalarWhereInput!]
}

type IssueSubscriptionPayload {
  mutation: MutationType!
  node: Issue
  updatedFields: [String!]
  previousValues: IssuePreviousValues
}

input IssueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IssueWhereInput
  AND: [IssueSubscriptionWhereInput!]
  OR: [IssueSubscriptionWhereInput!]
  NOT: [IssueSubscriptionWhereInput!]
}

input IssueUpdateemojisInput {
  set: [String!]
}

input IssueUpdateInput {
  uri: String
  rarity: Rarity
  emojis: IssueUpdateemojisInput
  creator: EntityUpdateOneRequiredWithoutCreatedIssuesInput
  assets: AssetUpdateManyWithoutIssueInput
}

input IssueUpdateManyDataInput {
  uri: String
  rarity: Rarity
  emojis: IssueUpdateemojisInput
}

input IssueUpdateManyMutationInput {
  uri: String
  rarity: Rarity
  emojis: IssueUpdateemojisInput
}

input IssueUpdateManyWithoutCreatorInput {
  create: [IssueCreateWithoutCreatorInput!]
  delete: [IssueWhereUniqueInput!]
  connect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  disconnect: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutCreatorInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutCreatorInput!]
  deleteMany: [IssueScalarWhereInput!]
  updateMany: [IssueUpdateManyWithWhereNestedInput!]
}

input IssueUpdateManyWithWhereNestedInput {
  where: IssueScalarWhereInput!
  data: IssueUpdateManyDataInput!
}

input IssueUpdateOneRequiredWithoutAssetsInput {
  create: IssueCreateWithoutAssetsInput
  update: IssueUpdateWithoutAssetsDataInput
  upsert: IssueUpsertWithoutAssetsInput
  connect: IssueWhereUniqueInput
}

input IssueUpdateWithoutAssetsDataInput {
  uri: String
  rarity: Rarity
  emojis: IssueUpdateemojisInput
  creator: EntityUpdateOneRequiredWithoutCreatedIssuesInput
}

input IssueUpdateWithoutCreatorDataInput {
  uri: String
  rarity: Rarity
  emojis: IssueUpdateemojisInput
  assets: AssetUpdateManyWithoutIssueInput
}

input IssueUpdateWithWhereUniqueWithoutCreatorInput {
  where: IssueWhereUniqueInput!
  data: IssueUpdateWithoutCreatorDataInput!
}

input IssueUpsertWithoutAssetsInput {
  update: IssueUpdateWithoutAssetsDataInput!
  create: IssueCreateWithoutAssetsInput!
}

input IssueUpsertWithWhereUniqueWithoutCreatorInput {
  where: IssueWhereUniqueInput!
  update: IssueUpdateWithoutCreatorDataInput!
  create: IssueCreateWithoutCreatorInput!
}

input IssueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  rarity: Rarity
  rarity_not: Rarity
  rarity_in: [Rarity!]
  rarity_not_in: [Rarity!]
  creator: EntityWhereInput
  assets_every: AssetWhereInput
  assets_some: AssetWhereInput
  assets_none: AssetWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [IssueWhereInput!]
  OR: [IssueWhereInput!]
  NOT: [IssueWhereInput!]
}

input IssueWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type Mutation {
  createAsset(data: AssetCreateInput!): Asset!
  updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
  updateManyAssets(data: AssetUpdateManyMutationInput!, where: AssetWhereInput): BatchPayload!
  upsertAsset(where: AssetWhereUniqueInput!, create: AssetCreateInput!, update: AssetUpdateInput!): Asset!
  deleteAsset(where: AssetWhereUniqueInput!): Asset
  deleteManyAssets(where: AssetWhereInput): BatchPayload!
  createEntity(data: EntityCreateInput!): Entity!
  updateEntity(data: EntityUpdateInput!, where: EntityWhereUniqueInput!): Entity
  updateManyEntities(data: EntityUpdateManyMutationInput!, where: EntityWhereInput): BatchPayload!
  upsertEntity(where: EntityWhereUniqueInput!, create: EntityCreateInput!, update: EntityUpdateInput!): Entity!
  deleteEntity(where: EntityWhereUniqueInput!): Entity
  deleteManyEntities(where: EntityWhereInput): BatchPayload!
  createExhibition(data: ExhibitionCreateInput!): Exhibition!
  updateExhibition(data: ExhibitionUpdateInput!, where: ExhibitionWhereUniqueInput!): Exhibition
  updateManyExhibitions(data: ExhibitionUpdateManyMutationInput!, where: ExhibitionWhereInput): BatchPayload!
  upsertExhibition(where: ExhibitionWhereUniqueInput!, create: ExhibitionCreateInput!, update: ExhibitionUpdateInput!): Exhibition!
  deleteExhibition(where: ExhibitionWhereUniqueInput!): Exhibition
  deleteManyExhibitions(where: ExhibitionWhereInput): BatchPayload!
  createIssue(data: IssueCreateInput!): Issue!
  updateIssue(data: IssueUpdateInput!, where: IssueWhereUniqueInput!): Issue
  updateManyIssues(data: IssueUpdateManyMutationInput!, where: IssueWhereInput): BatchPayload!
  upsertIssue(where: IssueWhereUniqueInput!, create: IssueCreateInput!, update: IssueUpdateInput!): Issue!
  deleteIssue(where: IssueWhereUniqueInput!): Issue
  deleteManyIssues(where: IssueWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createShow(data: ShowCreateInput!): Show!
  updateShow(data: ShowUpdateInput!, where: ShowWhereUniqueInput!): Show
  updateManyShows(data: ShowUpdateManyMutationInput!, where: ShowWhereInput): BatchPayload!
  upsertShow(where: ShowWhereUniqueInput!, create: ShowCreateInput!, update: ShowUpdateInput!): Show!
  deleteShow(where: ShowWhereUniqueInput!): Show
  deleteManyShows(where: ShowWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset]!
  assetsConnection(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssetConnection!
  entity(where: EntityWhereUniqueInput!): Entity
  entities(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Entity]!
  entitiesConnection(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EntityConnection!
  exhibition(where: ExhibitionWhereUniqueInput!): Exhibition
  exhibitions(where: ExhibitionWhereInput, orderBy: ExhibitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exhibition]!
  exhibitionsConnection(where: ExhibitionWhereInput, orderBy: ExhibitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExhibitionConnection!
  issue(where: IssueWhereUniqueInput!): Issue
  issues(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Issue]!
  issuesConnection(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IssueConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  show(where: ShowWhereUniqueInput!): Show
  shows(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show]!
  showsConnection(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShowConnection!
  node(id: ID!): Node
}

enum Rarity {
  COMMON
  RARE
}

type Room {
  id: ID!
  entryId: ID!
  x: Int!
  y: Int!
  exhibition: Exhibition!
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  entryId: ID!
  x: Int!
  y: Int!
  exhibition: ExhibitionCreateOneWithoutRoomsInput!
  assets: AssetCreateManyWithoutRoomsInput
}

input RoomCreateManyWithoutAssetsInput {
  create: [RoomCreateWithoutAssetsInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateManyWithoutExhibitionInput {
  create: [RoomCreateWithoutExhibitionInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateWithoutAssetsInput {
  id: ID
  entryId: ID!
  x: Int!
  y: Int!
  exhibition: ExhibitionCreateOneWithoutRoomsInput!
}

input RoomCreateWithoutExhibitionInput {
  id: ID
  entryId: ID!
  x: Int!
  y: Int!
  assets: AssetCreateManyWithoutRoomsInput
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  entryId_ASC
  entryId_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
}

type RoomPreviousValues {
  id: ID!
  entryId: ID!
  x: Int!
  y: Int!
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  entryId: ID
  entryId_not: ID
  entryId_in: [ID!]
  entryId_not_in: [ID!]
  entryId_lt: ID
  entryId_lte: ID
  entryId_gt: ID
  entryId_gte: ID
  entryId_contains: ID
  entryId_not_contains: ID
  entryId_starts_with: ID
  entryId_not_starts_with: ID
  entryId_ends_with: ID
  entryId_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateInput {
  entryId: ID
  x: Int
  y: Int
  exhibition: ExhibitionUpdateOneRequiredWithoutRoomsInput
  assets: AssetUpdateManyWithoutRoomsInput
}

input RoomUpdateManyDataInput {
  entryId: ID
  x: Int
  y: Int
}

input RoomUpdateManyMutationInput {
  entryId: ID
  x: Int
  y: Int
}

input RoomUpdateManyWithoutAssetsInput {
  create: [RoomCreateWithoutAssetsInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutAssetsInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutAssetsInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithoutExhibitionInput {
  create: [RoomCreateWithoutExhibitionInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutExhibitionInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutExhibitionInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateWithoutAssetsDataInput {
  entryId: ID
  x: Int
  y: Int
  exhibition: ExhibitionUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateWithoutExhibitionDataInput {
  entryId: ID
  x: Int
  y: Int
  assets: AssetUpdateManyWithoutRoomsInput
}

input RoomUpdateWithWhereUniqueWithoutAssetsInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutAssetsDataInput!
}

input RoomUpdateWithWhereUniqueWithoutExhibitionInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutExhibitionDataInput!
}

input RoomUpsertWithWhereUniqueWithoutAssetsInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutAssetsDataInput!
  create: RoomCreateWithoutAssetsInput!
}

input RoomUpsertWithWhereUniqueWithoutExhibitionInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutExhibitionDataInput!
  create: RoomCreateWithoutExhibitionInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  entryId: ID
  entryId_not: ID
  entryId_in: [ID!]
  entryId_not_in: [ID!]
  entryId_lt: ID
  entryId_lte: ID
  entryId_gt: ID
  entryId_gte: ID
  entryId_contains: ID
  entryId_not_contains: ID
  entryId_starts_with: ID
  entryId_not_starts_with: ID
  entryId_ends_with: ID
  entryId_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  exhibition: ExhibitionWhereInput
  assets_every: AssetWhereInput
  assets_some: AssetWhereInput
  assets_none: AssetWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
  entryId: ID
}

type Show {
  id: ID!
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  exhibition: Exhibition!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ShowConnection {
  pageInfo: PageInfo!
  edges: [ShowEdge]!
  aggregate: AggregateShow!
}

input ShowCreateInput {
  id: ID
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  exhibition: ExhibitionCreateOneWithoutShowsInput!
}

input ShowCreateManyWithoutExhibitionInput {
  create: [ShowCreateWithoutExhibitionInput!]
  connect: [ShowWhereUniqueInput!]
}

input ShowCreateWithoutExhibitionInput {
  id: ID
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
}

type ShowEdge {
  node: Show!
  cursor: String!
}

enum ShowOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  opensAt_ASC
  opensAt_DESC
  closesAt_ASC
  closesAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ShowPreviousValues {
  id: ID!
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ShowScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  opensAt: DateTime
  opensAt_not: DateTime
  opensAt_in: [DateTime!]
  opensAt_not_in: [DateTime!]
  opensAt_lt: DateTime
  opensAt_lte: DateTime
  opensAt_gt: DateTime
  opensAt_gte: DateTime
  closesAt: DateTime
  closesAt_not: DateTime
  closesAt_in: [DateTime!]
  closesAt_not_in: [DateTime!]
  closesAt_lt: DateTime
  closesAt_lte: DateTime
  closesAt_gt: DateTime
  closesAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ShowScalarWhereInput!]
  OR: [ShowScalarWhereInput!]
  NOT: [ShowScalarWhereInput!]
}

type ShowSubscriptionPayload {
  mutation: MutationType!
  node: Show
  updatedFields: [String!]
  previousValues: ShowPreviousValues
}

input ShowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShowWhereInput
  AND: [ShowSubscriptionWhereInput!]
  OR: [ShowSubscriptionWhereInput!]
  NOT: [ShowSubscriptionWhereInput!]
}

input ShowUpdateInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
  exhibition: ExhibitionUpdateOneRequiredWithoutShowsInput
}

input ShowUpdateManyDataInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
}

input ShowUpdateManyMutationInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
}

input ShowUpdateManyWithoutExhibitionInput {
  create: [ShowCreateWithoutExhibitionInput!]
  delete: [ShowWhereUniqueInput!]
  connect: [ShowWhereUniqueInput!]
  set: [ShowWhereUniqueInput!]
  disconnect: [ShowWhereUniqueInput!]
  update: [ShowUpdateWithWhereUniqueWithoutExhibitionInput!]
  upsert: [ShowUpsertWithWhereUniqueWithoutExhibitionInput!]
  deleteMany: [ShowScalarWhereInput!]
  updateMany: [ShowUpdateManyWithWhereNestedInput!]
}

input ShowUpdateManyWithWhereNestedInput {
  where: ShowScalarWhereInput!
  data: ShowUpdateManyDataInput!
}

input ShowUpdateWithoutExhibitionDataInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
}

input ShowUpdateWithWhereUniqueWithoutExhibitionInput {
  where: ShowWhereUniqueInput!
  data: ShowUpdateWithoutExhibitionDataInput!
}

input ShowUpsertWithWhereUniqueWithoutExhibitionInput {
  where: ShowWhereUniqueInput!
  update: ShowUpdateWithoutExhibitionDataInput!
  create: ShowCreateWithoutExhibitionInput!
}

input ShowWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  opensAt: DateTime
  opensAt_not: DateTime
  opensAt_in: [DateTime!]
  opensAt_not_in: [DateTime!]
  opensAt_lt: DateTime
  opensAt_lte: DateTime
  opensAt_gt: DateTime
  opensAt_gte: DateTime
  closesAt: DateTime
  closesAt_not: DateTime
  closesAt_in: [DateTime!]
  closesAt_not_in: [DateTime!]
  closesAt_lt: DateTime
  closesAt_lte: DateTime
  closesAt_gt: DateTime
  closesAt_gte: DateTime
  exhibition: ExhibitionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ShowWhereInput!]
  OR: [ShowWhereInput!]
  NOT: [ShowWhereInput!]
}

input ShowWhereUniqueInput {
  id: ID
}

type Subscription {
  asset(where: AssetSubscriptionWhereInput): AssetSubscriptionPayload
  entity(where: EntitySubscriptionWhereInput): EntitySubscriptionPayload
  exhibition(where: ExhibitionSubscriptionWhereInput): ExhibitionSubscriptionPayload
  issue(where: IssueSubscriptionWhereInput): IssueSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  show(where: ShowSubscriptionWhereInput): ShowSubscriptionPayload
}
