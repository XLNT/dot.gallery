type AggregateAsset {
  count: Int!
}

type AggregateCounterfactualToken {
  count: Int!
}

type AggregateEntity {
  count: Int!
}

type AggregateExhibition {
  count: Int!
}

type AggregatePlacement {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateShow {
  count: Int!
}

type AggregateTicket {
  count: Int!
}

type Asset {
  id: ID!
  uri: String!
  owner: Entity!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssetConnection {
  pageInfo: PageInfo!
  edges: [AssetEdge]!
  aggregate: AggregateAsset!
}

input AssetCreateInput {
  id: ID
  uri: String!
  owner: EntityCreateOneWithoutAssetsInput!
}

input AssetCreateManyWithoutOwnerInput {
  create: [AssetCreateWithoutOwnerInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateWithoutOwnerInput {
  id: ID
  uri: String!
}

type AssetEdge {
  node: Asset!
  cursor: String!
}

enum AssetOrderByInput {
  id_ASC
  id_DESC
  uri_ASC
  uri_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AssetPreviousValues {
  id: ID!
  uri: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AssetScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  NOT: [AssetScalarWhereInput!]
}

type AssetSubscriptionPayload {
  mutation: MutationType!
  node: Asset
  updatedFields: [String!]
  previousValues: AssetPreviousValues
}

input AssetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AssetWhereInput
  AND: [AssetSubscriptionWhereInput!]
  OR: [AssetSubscriptionWhereInput!]
  NOT: [AssetSubscriptionWhereInput!]
}

input AssetUpdateInput {
  uri: String
  owner: EntityUpdateOneRequiredWithoutAssetsInput
}

input AssetUpdateManyDataInput {
  uri: String
}

input AssetUpdateManyMutationInput {
  uri: String
}

input AssetUpdateManyWithoutOwnerInput {
  create: [AssetCreateWithoutOwnerInput!]
  delete: [AssetWhereUniqueInput!]
  connect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [AssetScalarWhereInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
}

input AssetUpdateManyWithWhereNestedInput {
  where: AssetScalarWhereInput!
  data: AssetUpdateManyDataInput!
}

input AssetUpdateWithoutOwnerDataInput {
  uri: String
}

input AssetUpdateWithWhereUniqueWithoutOwnerInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateWithoutOwnerDataInput!
}

input AssetUpsertWithWhereUniqueWithoutOwnerInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateWithoutOwnerDataInput!
  create: AssetCreateWithoutOwnerInput!
}

input AssetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  owner: EntityWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  NOT: [AssetWhereInput!]
}

input AssetWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type CounterfactualToken {
  id: ID!
  tokenURI: String!
  owner: Entity!
  placement: Placement
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CounterfactualTokenConnection {
  pageInfo: PageInfo!
  edges: [CounterfactualTokenEdge]!
  aggregate: AggregateCounterfactualToken!
}

input CounterfactualTokenCreateInput {
  id: ID
  tokenURI: String!
  owner: EntityCreateOneWithoutCounterfactualTokensInput!
  placement: PlacementCreateOneWithoutCounterfactualTokenInput
}

input CounterfactualTokenCreateManyWithoutOwnerInput {
  create: [CounterfactualTokenCreateWithoutOwnerInput!]
  connect: [CounterfactualTokenWhereUniqueInput!]
}

input CounterfactualTokenCreateOneWithoutPlacementInput {
  create: CounterfactualTokenCreateWithoutPlacementInput
  connect: CounterfactualTokenWhereUniqueInput
}

input CounterfactualTokenCreateWithoutOwnerInput {
  id: ID
  tokenURI: String!
  placement: PlacementCreateOneWithoutCounterfactualTokenInput
}

input CounterfactualTokenCreateWithoutPlacementInput {
  id: ID
  tokenURI: String!
  owner: EntityCreateOneWithoutCounterfactualTokensInput!
}

type CounterfactualTokenEdge {
  node: CounterfactualToken!
  cursor: String!
}

enum CounterfactualTokenOrderByInput {
  id_ASC
  id_DESC
  tokenURI_ASC
  tokenURI_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CounterfactualTokenPreviousValues {
  id: ID!
  tokenURI: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CounterfactualTokenScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tokenURI: String
  tokenURI_not: String
  tokenURI_in: [String!]
  tokenURI_not_in: [String!]
  tokenURI_lt: String
  tokenURI_lte: String
  tokenURI_gt: String
  tokenURI_gte: String
  tokenURI_contains: String
  tokenURI_not_contains: String
  tokenURI_starts_with: String
  tokenURI_not_starts_with: String
  tokenURI_ends_with: String
  tokenURI_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CounterfactualTokenScalarWhereInput!]
  OR: [CounterfactualTokenScalarWhereInput!]
  NOT: [CounterfactualTokenScalarWhereInput!]
}

type CounterfactualTokenSubscriptionPayload {
  mutation: MutationType!
  node: CounterfactualToken
  updatedFields: [String!]
  previousValues: CounterfactualTokenPreviousValues
}

input CounterfactualTokenSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CounterfactualTokenWhereInput
  AND: [CounterfactualTokenSubscriptionWhereInput!]
  OR: [CounterfactualTokenSubscriptionWhereInput!]
  NOT: [CounterfactualTokenSubscriptionWhereInput!]
}

input CounterfactualTokenUpdateInput {
  tokenURI: String
  owner: EntityUpdateOneRequiredWithoutCounterfactualTokensInput
  placement: PlacementUpdateOneWithoutCounterfactualTokenInput
}

input CounterfactualTokenUpdateManyDataInput {
  tokenURI: String
}

input CounterfactualTokenUpdateManyMutationInput {
  tokenURI: String
}

input CounterfactualTokenUpdateManyWithoutOwnerInput {
  create: [CounterfactualTokenCreateWithoutOwnerInput!]
  delete: [CounterfactualTokenWhereUniqueInput!]
  connect: [CounterfactualTokenWhereUniqueInput!]
  set: [CounterfactualTokenWhereUniqueInput!]
  disconnect: [CounterfactualTokenWhereUniqueInput!]
  update: [CounterfactualTokenUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [CounterfactualTokenUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [CounterfactualTokenScalarWhereInput!]
  updateMany: [CounterfactualTokenUpdateManyWithWhereNestedInput!]
}

input CounterfactualTokenUpdateManyWithWhereNestedInput {
  where: CounterfactualTokenScalarWhereInput!
  data: CounterfactualTokenUpdateManyDataInput!
}

input CounterfactualTokenUpdateOneRequiredWithoutPlacementInput {
  create: CounterfactualTokenCreateWithoutPlacementInput
  update: CounterfactualTokenUpdateWithoutPlacementDataInput
  upsert: CounterfactualTokenUpsertWithoutPlacementInput
  connect: CounterfactualTokenWhereUniqueInput
}

input CounterfactualTokenUpdateWithoutOwnerDataInput {
  tokenURI: String
  placement: PlacementUpdateOneWithoutCounterfactualTokenInput
}

input CounterfactualTokenUpdateWithoutPlacementDataInput {
  tokenURI: String
  owner: EntityUpdateOneRequiredWithoutCounterfactualTokensInput
}

input CounterfactualTokenUpdateWithWhereUniqueWithoutOwnerInput {
  where: CounterfactualTokenWhereUniqueInput!
  data: CounterfactualTokenUpdateWithoutOwnerDataInput!
}

input CounterfactualTokenUpsertWithoutPlacementInput {
  update: CounterfactualTokenUpdateWithoutPlacementDataInput!
  create: CounterfactualTokenCreateWithoutPlacementInput!
}

input CounterfactualTokenUpsertWithWhereUniqueWithoutOwnerInput {
  where: CounterfactualTokenWhereUniqueInput!
  update: CounterfactualTokenUpdateWithoutOwnerDataInput!
  create: CounterfactualTokenCreateWithoutOwnerInput!
}

input CounterfactualTokenWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tokenURI: String
  tokenURI_not: String
  tokenURI_in: [String!]
  tokenURI_not_in: [String!]
  tokenURI_lt: String
  tokenURI_lte: String
  tokenURI_gt: String
  tokenURI_gte: String
  tokenURI_contains: String
  tokenURI_not_contains: String
  tokenURI_starts_with: String
  tokenURI_not_starts_with: String
  tokenURI_ends_with: String
  tokenURI_not_ends_with: String
  owner: EntityWhereInput
  placement: PlacementWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CounterfactualTokenWhereInput!]
  OR: [CounterfactualTokenWhereInput!]
  NOT: [CounterfactualTokenWhereInput!]
}

input CounterfactualTokenWhereUniqueInput {
  id: ID
}

scalar DateTime

type Entity {
  id: ID!
  handle: String
  email: String!
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
  counterfactualTokens(where: CounterfactualTokenWhereInput, orderBy: CounterfactualTokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CounterfactualToken!]
  placements(where: PlacementWhereInput, orderBy: PlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Placement!]
  tickets(where: TicketWhereInput, orderBy: TicketOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ticket!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]!
  aggregate: AggregateEntity!
}

input EntityCreateInput {
  id: ID
  handle: String
  email: String!
  assets: AssetCreateManyWithoutOwnerInput
  counterfactualTokens: CounterfactualTokenCreateManyWithoutOwnerInput
  placements: PlacementCreateManyWithoutEntityInput
  tickets: TicketCreateManyWithoutOwnerInput
}

input EntityCreateOneWithoutAssetsInput {
  create: EntityCreateWithoutAssetsInput
  connect: EntityWhereUniqueInput
}

input EntityCreateOneWithoutCounterfactualTokensInput {
  create: EntityCreateWithoutCounterfactualTokensInput
  connect: EntityWhereUniqueInput
}

input EntityCreateOneWithoutPlacementsInput {
  create: EntityCreateWithoutPlacementsInput
  connect: EntityWhereUniqueInput
}

input EntityCreateOneWithoutTicketsInput {
  create: EntityCreateWithoutTicketsInput
  connect: EntityWhereUniqueInput
}

input EntityCreateWithoutAssetsInput {
  id: ID
  handle: String
  email: String!
  counterfactualTokens: CounterfactualTokenCreateManyWithoutOwnerInput
  placements: PlacementCreateManyWithoutEntityInput
  tickets: TicketCreateManyWithoutOwnerInput
}

input EntityCreateWithoutCounterfactualTokensInput {
  id: ID
  handle: String
  email: String!
  assets: AssetCreateManyWithoutOwnerInput
  placements: PlacementCreateManyWithoutEntityInput
  tickets: TicketCreateManyWithoutOwnerInput
}

input EntityCreateWithoutPlacementsInput {
  id: ID
  handle: String
  email: String!
  assets: AssetCreateManyWithoutOwnerInput
  counterfactualTokens: CounterfactualTokenCreateManyWithoutOwnerInput
  tickets: TicketCreateManyWithoutOwnerInput
}

input EntityCreateWithoutTicketsInput {
  id: ID
  handle: String
  email: String!
  assets: AssetCreateManyWithoutOwnerInput
  counterfactualTokens: CounterfactualTokenCreateManyWithoutOwnerInput
  placements: PlacementCreateManyWithoutEntityInput
}

type EntityEdge {
  node: Entity!
  cursor: String!
}

enum EntityOrderByInput {
  id_ASC
  id_DESC
  handle_ASC
  handle_DESC
  email_ASC
  email_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EntityPreviousValues {
  id: ID!
  handle: String
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EntitySubscriptionPayload {
  mutation: MutationType!
  node: Entity
  updatedFields: [String!]
  previousValues: EntityPreviousValues
}

input EntitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EntityWhereInput
  AND: [EntitySubscriptionWhereInput!]
  OR: [EntitySubscriptionWhereInput!]
  NOT: [EntitySubscriptionWhereInput!]
}

input EntityUpdateInput {
  handle: String
  email: String
  assets: AssetUpdateManyWithoutOwnerInput
  counterfactualTokens: CounterfactualTokenUpdateManyWithoutOwnerInput
  placements: PlacementUpdateManyWithoutEntityInput
  tickets: TicketUpdateManyWithoutOwnerInput
}

input EntityUpdateManyMutationInput {
  handle: String
  email: String
}

input EntityUpdateOneRequiredWithoutAssetsInput {
  create: EntityCreateWithoutAssetsInput
  update: EntityUpdateWithoutAssetsDataInput
  upsert: EntityUpsertWithoutAssetsInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateOneRequiredWithoutCounterfactualTokensInput {
  create: EntityCreateWithoutCounterfactualTokensInput
  update: EntityUpdateWithoutCounterfactualTokensDataInput
  upsert: EntityUpsertWithoutCounterfactualTokensInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateOneRequiredWithoutPlacementsInput {
  create: EntityCreateWithoutPlacementsInput
  update: EntityUpdateWithoutPlacementsDataInput
  upsert: EntityUpsertWithoutPlacementsInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateOneRequiredWithoutTicketsInput {
  create: EntityCreateWithoutTicketsInput
  update: EntityUpdateWithoutTicketsDataInput
  upsert: EntityUpsertWithoutTicketsInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateWithoutAssetsDataInput {
  handle: String
  email: String
  counterfactualTokens: CounterfactualTokenUpdateManyWithoutOwnerInput
  placements: PlacementUpdateManyWithoutEntityInput
  tickets: TicketUpdateManyWithoutOwnerInput
}

input EntityUpdateWithoutCounterfactualTokensDataInput {
  handle: String
  email: String
  assets: AssetUpdateManyWithoutOwnerInput
  placements: PlacementUpdateManyWithoutEntityInput
  tickets: TicketUpdateManyWithoutOwnerInput
}

input EntityUpdateWithoutPlacementsDataInput {
  handle: String
  email: String
  assets: AssetUpdateManyWithoutOwnerInput
  counterfactualTokens: CounterfactualTokenUpdateManyWithoutOwnerInput
  tickets: TicketUpdateManyWithoutOwnerInput
}

input EntityUpdateWithoutTicketsDataInput {
  handle: String
  email: String
  assets: AssetUpdateManyWithoutOwnerInput
  counterfactualTokens: CounterfactualTokenUpdateManyWithoutOwnerInput
  placements: PlacementUpdateManyWithoutEntityInput
}

input EntityUpsertWithoutAssetsInput {
  update: EntityUpdateWithoutAssetsDataInput!
  create: EntityCreateWithoutAssetsInput!
}

input EntityUpsertWithoutCounterfactualTokensInput {
  update: EntityUpdateWithoutCounterfactualTokensDataInput!
  create: EntityCreateWithoutCounterfactualTokensInput!
}

input EntityUpsertWithoutPlacementsInput {
  update: EntityUpdateWithoutPlacementsDataInput!
  create: EntityCreateWithoutPlacementsInput!
}

input EntityUpsertWithoutTicketsInput {
  update: EntityUpdateWithoutTicketsDataInput!
  create: EntityCreateWithoutTicketsInput!
}

input EntityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  assets_every: AssetWhereInput
  assets_some: AssetWhereInput
  assets_none: AssetWhereInput
  counterfactualTokens_every: CounterfactualTokenWhereInput
  counterfactualTokens_some: CounterfactualTokenWhereInput
  counterfactualTokens_none: CounterfactualTokenWhereInput
  placements_every: PlacementWhereInput
  placements_some: PlacementWhereInput
  placements_none: PlacementWhereInput
  tickets_every: TicketWhereInput
  tickets_some: TicketWhereInput
  tickets_none: TicketWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EntityWhereInput!]
  OR: [EntityWhereInput!]
  NOT: [EntityWhereInput!]
}

input EntityWhereUniqueInput {
  id: ID
  handle: String
  email: String
}

type Exhibition {
  id: ID!
  title: String!
  number: Int!
  capacity: Int!
  theme: Json
  extent: Int!
  shows(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show!]
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  tickets(where: TicketWhereInput, orderBy: TicketOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ticket!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExhibitionConnection {
  pageInfo: PageInfo!
  edges: [ExhibitionEdge]!
  aggregate: AggregateExhibition!
}

input ExhibitionCreateInput {
  id: ID
  title: String!
  number: Int!
  capacity: Int!
  theme: Json
  extent: Int
  shows: ShowCreateManyWithoutExhibitionInput
  rooms: RoomCreateManyWithoutExhibitionInput
  tickets: TicketCreateManyWithoutExhibitionInput
}

input ExhibitionCreateOneWithoutRoomsInput {
  create: ExhibitionCreateWithoutRoomsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionCreateOneWithoutShowsInput {
  create: ExhibitionCreateWithoutShowsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionCreateOneWithoutTicketsInput {
  create: ExhibitionCreateWithoutTicketsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionCreateWithoutRoomsInput {
  id: ID
  title: String!
  number: Int!
  capacity: Int!
  theme: Json
  extent: Int
  shows: ShowCreateManyWithoutExhibitionInput
  tickets: TicketCreateManyWithoutExhibitionInput
}

input ExhibitionCreateWithoutShowsInput {
  id: ID
  title: String!
  number: Int!
  capacity: Int!
  theme: Json
  extent: Int
  rooms: RoomCreateManyWithoutExhibitionInput
  tickets: TicketCreateManyWithoutExhibitionInput
}

input ExhibitionCreateWithoutTicketsInput {
  id: ID
  title: String!
  number: Int!
  capacity: Int!
  theme: Json
  extent: Int
  shows: ShowCreateManyWithoutExhibitionInput
  rooms: RoomCreateManyWithoutExhibitionInput
}

type ExhibitionEdge {
  node: Exhibition!
  cursor: String!
}

enum ExhibitionOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  number_ASC
  number_DESC
  capacity_ASC
  capacity_DESC
  theme_ASC
  theme_DESC
  extent_ASC
  extent_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExhibitionPreviousValues {
  id: ID!
  title: String!
  number: Int!
  capacity: Int!
  theme: Json
  extent: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExhibitionSubscriptionPayload {
  mutation: MutationType!
  node: Exhibition
  updatedFields: [String!]
  previousValues: ExhibitionPreviousValues
}

input ExhibitionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExhibitionWhereInput
  AND: [ExhibitionSubscriptionWhereInput!]
  OR: [ExhibitionSubscriptionWhereInput!]
  NOT: [ExhibitionSubscriptionWhereInput!]
}

input ExhibitionUpdateInput {
  title: String
  number: Int
  capacity: Int
  theme: Json
  extent: Int
  shows: ShowUpdateManyWithoutExhibitionInput
  rooms: RoomUpdateManyWithoutExhibitionInput
  tickets: TicketUpdateManyWithoutExhibitionInput
}

input ExhibitionUpdateManyMutationInput {
  title: String
  number: Int
  capacity: Int
  theme: Json
  extent: Int
}

input ExhibitionUpdateOneRequiredWithoutRoomsInput {
  create: ExhibitionCreateWithoutRoomsInput
  update: ExhibitionUpdateWithoutRoomsDataInput
  upsert: ExhibitionUpsertWithoutRoomsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionUpdateOneRequiredWithoutShowsInput {
  create: ExhibitionCreateWithoutShowsInput
  update: ExhibitionUpdateWithoutShowsDataInput
  upsert: ExhibitionUpsertWithoutShowsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionUpdateOneRequiredWithoutTicketsInput {
  create: ExhibitionCreateWithoutTicketsInput
  update: ExhibitionUpdateWithoutTicketsDataInput
  upsert: ExhibitionUpsertWithoutTicketsInput
  connect: ExhibitionWhereUniqueInput
}

input ExhibitionUpdateWithoutRoomsDataInput {
  title: String
  number: Int
  capacity: Int
  theme: Json
  extent: Int
  shows: ShowUpdateManyWithoutExhibitionInput
  tickets: TicketUpdateManyWithoutExhibitionInput
}

input ExhibitionUpdateWithoutShowsDataInput {
  title: String
  number: Int
  capacity: Int
  theme: Json
  extent: Int
  rooms: RoomUpdateManyWithoutExhibitionInput
  tickets: TicketUpdateManyWithoutExhibitionInput
}

input ExhibitionUpdateWithoutTicketsDataInput {
  title: String
  number: Int
  capacity: Int
  theme: Json
  extent: Int
  shows: ShowUpdateManyWithoutExhibitionInput
  rooms: RoomUpdateManyWithoutExhibitionInput
}

input ExhibitionUpsertWithoutRoomsInput {
  update: ExhibitionUpdateWithoutRoomsDataInput!
  create: ExhibitionCreateWithoutRoomsInput!
}

input ExhibitionUpsertWithoutShowsInput {
  update: ExhibitionUpdateWithoutShowsDataInput!
  create: ExhibitionCreateWithoutShowsInput!
}

input ExhibitionUpsertWithoutTicketsInput {
  update: ExhibitionUpdateWithoutTicketsDataInput!
  create: ExhibitionCreateWithoutTicketsInput!
}

input ExhibitionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  extent: Int
  extent_not: Int
  extent_in: [Int!]
  extent_not_in: [Int!]
  extent_lt: Int
  extent_lte: Int
  extent_gt: Int
  extent_gte: Int
  shows_every: ShowWhereInput
  shows_some: ShowWhereInput
  shows_none: ShowWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  tickets_every: TicketWhereInput
  tickets_some: TicketWhereInput
  tickets_none: TicketWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExhibitionWhereInput!]
  OR: [ExhibitionWhereInput!]
  NOT: [ExhibitionWhereInput!]
}

input ExhibitionWhereUniqueInput {
  id: ID
  number: Int
}

scalar Json

scalar Long

type Mutation {
  createAsset(data: AssetCreateInput!): Asset!
  updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
  updateManyAssets(data: AssetUpdateManyMutationInput!, where: AssetWhereInput): BatchPayload!
  upsertAsset(where: AssetWhereUniqueInput!, create: AssetCreateInput!, update: AssetUpdateInput!): Asset!
  deleteAsset(where: AssetWhereUniqueInput!): Asset
  deleteManyAssets(where: AssetWhereInput): BatchPayload!
  createCounterfactualToken(data: CounterfactualTokenCreateInput!): CounterfactualToken!
  updateCounterfactualToken(data: CounterfactualTokenUpdateInput!, where: CounterfactualTokenWhereUniqueInput!): CounterfactualToken
  updateManyCounterfactualTokens(data: CounterfactualTokenUpdateManyMutationInput!, where: CounterfactualTokenWhereInput): BatchPayload!
  upsertCounterfactualToken(where: CounterfactualTokenWhereUniqueInput!, create: CounterfactualTokenCreateInput!, update: CounterfactualTokenUpdateInput!): CounterfactualToken!
  deleteCounterfactualToken(where: CounterfactualTokenWhereUniqueInput!): CounterfactualToken
  deleteManyCounterfactualTokens(where: CounterfactualTokenWhereInput): BatchPayload!
  createEntity(data: EntityCreateInput!): Entity!
  updateEntity(data: EntityUpdateInput!, where: EntityWhereUniqueInput!): Entity
  updateManyEntities(data: EntityUpdateManyMutationInput!, where: EntityWhereInput): BatchPayload!
  upsertEntity(where: EntityWhereUniqueInput!, create: EntityCreateInput!, update: EntityUpdateInput!): Entity!
  deleteEntity(where: EntityWhereUniqueInput!): Entity
  deleteManyEntities(where: EntityWhereInput): BatchPayload!
  createExhibition(data: ExhibitionCreateInput!): Exhibition!
  updateExhibition(data: ExhibitionUpdateInput!, where: ExhibitionWhereUniqueInput!): Exhibition
  updateManyExhibitions(data: ExhibitionUpdateManyMutationInput!, where: ExhibitionWhereInput): BatchPayload!
  upsertExhibition(where: ExhibitionWhereUniqueInput!, create: ExhibitionCreateInput!, update: ExhibitionUpdateInput!): Exhibition!
  deleteExhibition(where: ExhibitionWhereUniqueInput!): Exhibition
  deleteManyExhibitions(where: ExhibitionWhereInput): BatchPayload!
  createPlacement(data: PlacementCreateInput!): Placement!
  updatePlacement(data: PlacementUpdateInput!, where: PlacementWhereUniqueInput!): Placement
  updateManyPlacements(data: PlacementUpdateManyMutationInput!, where: PlacementWhereInput): BatchPayload!
  upsertPlacement(where: PlacementWhereUniqueInput!, create: PlacementCreateInput!, update: PlacementUpdateInput!): Placement!
  deletePlacement(where: PlacementWhereUniqueInput!): Placement
  deleteManyPlacements(where: PlacementWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createShow(data: ShowCreateInput!): Show!
  updateShow(data: ShowUpdateInput!, where: ShowWhereUniqueInput!): Show
  updateManyShows(data: ShowUpdateManyMutationInput!, where: ShowWhereInput): BatchPayload!
  upsertShow(where: ShowWhereUniqueInput!, create: ShowCreateInput!, update: ShowUpdateInput!): Show!
  deleteShow(where: ShowWhereUniqueInput!): Show
  deleteManyShows(where: ShowWhereInput): BatchPayload!
  createTicket(data: TicketCreateInput!): Ticket!
  updateTicket(data: TicketUpdateInput!, where: TicketWhereUniqueInput!): Ticket
  upsertTicket(where: TicketWhereUniqueInput!, create: TicketCreateInput!, update: TicketUpdateInput!): Ticket!
  deleteTicket(where: TicketWhereUniqueInput!): Ticket
  deleteManyTickets(where: TicketWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Placement {
  id: ID!
  x: Int!
  y: Int!
  entity: Entity!
  room: Room!
  counterfactualToken: CounterfactualToken!
  createdAt: DateTime!
}

type PlacementConnection {
  pageInfo: PageInfo!
  edges: [PlacementEdge]!
  aggregate: AggregatePlacement!
}

input PlacementCreateInput {
  id: ID
  x: Int!
  y: Int!
  entity: EntityCreateOneWithoutPlacementsInput!
  room: RoomCreateOneWithoutPlacementsInput!
  counterfactualToken: CounterfactualTokenCreateOneWithoutPlacementInput!
}

input PlacementCreateManyWithoutEntityInput {
  create: [PlacementCreateWithoutEntityInput!]
  connect: [PlacementWhereUniqueInput!]
}

input PlacementCreateManyWithoutRoomInput {
  create: [PlacementCreateWithoutRoomInput!]
  connect: [PlacementWhereUniqueInput!]
}

input PlacementCreateOneWithoutCounterfactualTokenInput {
  create: PlacementCreateWithoutCounterfactualTokenInput
  connect: PlacementWhereUniqueInput
}

input PlacementCreateWithoutCounterfactualTokenInput {
  id: ID
  x: Int!
  y: Int!
  entity: EntityCreateOneWithoutPlacementsInput!
  room: RoomCreateOneWithoutPlacementsInput!
}

input PlacementCreateWithoutEntityInput {
  id: ID
  x: Int!
  y: Int!
  room: RoomCreateOneWithoutPlacementsInput!
  counterfactualToken: CounterfactualTokenCreateOneWithoutPlacementInput!
}

input PlacementCreateWithoutRoomInput {
  id: ID
  x: Int!
  y: Int!
  entity: EntityCreateOneWithoutPlacementsInput!
  counterfactualToken: CounterfactualTokenCreateOneWithoutPlacementInput!
}

type PlacementEdge {
  node: Placement!
  cursor: String!
}

enum PlacementOrderByInput {
  id_ASC
  id_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  createdAt_ASC
  createdAt_DESC
}

type PlacementPreviousValues {
  id: ID!
  x: Int!
  y: Int!
  createdAt: DateTime!
}

input PlacementScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [PlacementScalarWhereInput!]
  OR: [PlacementScalarWhereInput!]
  NOT: [PlacementScalarWhereInput!]
}

type PlacementSubscriptionPayload {
  mutation: MutationType!
  node: Placement
  updatedFields: [String!]
  previousValues: PlacementPreviousValues
}

input PlacementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlacementWhereInput
  AND: [PlacementSubscriptionWhereInput!]
  OR: [PlacementSubscriptionWhereInput!]
  NOT: [PlacementSubscriptionWhereInput!]
}

input PlacementUpdateInput {
  x: Int
  y: Int
  entity: EntityUpdateOneRequiredWithoutPlacementsInput
  room: RoomUpdateOneRequiredWithoutPlacementsInput
  counterfactualToken: CounterfactualTokenUpdateOneRequiredWithoutPlacementInput
}

input PlacementUpdateManyDataInput {
  x: Int
  y: Int
}

input PlacementUpdateManyMutationInput {
  x: Int
  y: Int
}

input PlacementUpdateManyWithoutEntityInput {
  create: [PlacementCreateWithoutEntityInput!]
  delete: [PlacementWhereUniqueInput!]
  connect: [PlacementWhereUniqueInput!]
  set: [PlacementWhereUniqueInput!]
  disconnect: [PlacementWhereUniqueInput!]
  update: [PlacementUpdateWithWhereUniqueWithoutEntityInput!]
  upsert: [PlacementUpsertWithWhereUniqueWithoutEntityInput!]
  deleteMany: [PlacementScalarWhereInput!]
  updateMany: [PlacementUpdateManyWithWhereNestedInput!]
}

input PlacementUpdateManyWithoutRoomInput {
  create: [PlacementCreateWithoutRoomInput!]
  delete: [PlacementWhereUniqueInput!]
  connect: [PlacementWhereUniqueInput!]
  set: [PlacementWhereUniqueInput!]
  disconnect: [PlacementWhereUniqueInput!]
  update: [PlacementUpdateWithWhereUniqueWithoutRoomInput!]
  upsert: [PlacementUpsertWithWhereUniqueWithoutRoomInput!]
  deleteMany: [PlacementScalarWhereInput!]
  updateMany: [PlacementUpdateManyWithWhereNestedInput!]
}

input PlacementUpdateManyWithWhereNestedInput {
  where: PlacementScalarWhereInput!
  data: PlacementUpdateManyDataInput!
}

input PlacementUpdateOneWithoutCounterfactualTokenInput {
  create: PlacementCreateWithoutCounterfactualTokenInput
  update: PlacementUpdateWithoutCounterfactualTokenDataInput
  upsert: PlacementUpsertWithoutCounterfactualTokenInput
  delete: Boolean
  disconnect: Boolean
  connect: PlacementWhereUniqueInput
}

input PlacementUpdateWithoutCounterfactualTokenDataInput {
  x: Int
  y: Int
  entity: EntityUpdateOneRequiredWithoutPlacementsInput
  room: RoomUpdateOneRequiredWithoutPlacementsInput
}

input PlacementUpdateWithoutEntityDataInput {
  x: Int
  y: Int
  room: RoomUpdateOneRequiredWithoutPlacementsInput
  counterfactualToken: CounterfactualTokenUpdateOneRequiredWithoutPlacementInput
}

input PlacementUpdateWithoutRoomDataInput {
  x: Int
  y: Int
  entity: EntityUpdateOneRequiredWithoutPlacementsInput
  counterfactualToken: CounterfactualTokenUpdateOneRequiredWithoutPlacementInput
}

input PlacementUpdateWithWhereUniqueWithoutEntityInput {
  where: PlacementWhereUniqueInput!
  data: PlacementUpdateWithoutEntityDataInput!
}

input PlacementUpdateWithWhereUniqueWithoutRoomInput {
  where: PlacementWhereUniqueInput!
  data: PlacementUpdateWithoutRoomDataInput!
}

input PlacementUpsertWithoutCounterfactualTokenInput {
  update: PlacementUpdateWithoutCounterfactualTokenDataInput!
  create: PlacementCreateWithoutCounterfactualTokenInput!
}

input PlacementUpsertWithWhereUniqueWithoutEntityInput {
  where: PlacementWhereUniqueInput!
  update: PlacementUpdateWithoutEntityDataInput!
  create: PlacementCreateWithoutEntityInput!
}

input PlacementUpsertWithWhereUniqueWithoutRoomInput {
  where: PlacementWhereUniqueInput!
  update: PlacementUpdateWithoutRoomDataInput!
  create: PlacementCreateWithoutRoomInput!
}

input PlacementWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  entity: EntityWhereInput
  room: RoomWhereInput
  counterfactualToken: CounterfactualTokenWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [PlacementWhereInput!]
  OR: [PlacementWhereInput!]
  NOT: [PlacementWhereInput!]
}

input PlacementWhereUniqueInput {
  id: ID
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset]!
  assetsConnection(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssetConnection!
  counterfactualToken(where: CounterfactualTokenWhereUniqueInput!): CounterfactualToken
  counterfactualTokens(where: CounterfactualTokenWhereInput, orderBy: CounterfactualTokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CounterfactualToken]!
  counterfactualTokensConnection(where: CounterfactualTokenWhereInput, orderBy: CounterfactualTokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CounterfactualTokenConnection!
  entity(where: EntityWhereUniqueInput!): Entity
  entities(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Entity]!
  entitiesConnection(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EntityConnection!
  exhibition(where: ExhibitionWhereUniqueInput!): Exhibition
  exhibitions(where: ExhibitionWhereInput, orderBy: ExhibitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exhibition]!
  exhibitionsConnection(where: ExhibitionWhereInput, orderBy: ExhibitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExhibitionConnection!
  placement(where: PlacementWhereUniqueInput!): Placement
  placements(where: PlacementWhereInput, orderBy: PlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Placement]!
  placementsConnection(where: PlacementWhereInput, orderBy: PlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlacementConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  show(where: ShowWhereUniqueInput!): Show
  shows(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show]!
  showsConnection(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShowConnection!
  ticket(where: TicketWhereUniqueInput!): Ticket
  tickets(where: TicketWhereInput, orderBy: TicketOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ticket]!
  ticketsConnection(where: TicketWhereInput, orderBy: TicketOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TicketConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  entryId: ID!
  x: Int!
  y: Int!
  exhibition: Exhibition!
  placements(where: PlacementWhereInput, orderBy: PlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Placement!]
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  entryId: ID!
  x: Int!
  y: Int!
  exhibition: ExhibitionCreateOneWithoutRoomsInput!
  placements: PlacementCreateManyWithoutRoomInput
}

input RoomCreateManyWithoutExhibitionInput {
  create: [RoomCreateWithoutExhibitionInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateOneWithoutPlacementsInput {
  create: RoomCreateWithoutPlacementsInput
  connect: RoomWhereUniqueInput
}

input RoomCreateWithoutExhibitionInput {
  id: ID
  entryId: ID!
  x: Int!
  y: Int!
  placements: PlacementCreateManyWithoutRoomInput
}

input RoomCreateWithoutPlacementsInput {
  id: ID
  entryId: ID!
  x: Int!
  y: Int!
  exhibition: ExhibitionCreateOneWithoutRoomsInput!
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  entryId_ASC
  entryId_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
}

type RoomPreviousValues {
  id: ID!
  entryId: ID!
  x: Int!
  y: Int!
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  entryId: ID
  entryId_not: ID
  entryId_in: [ID!]
  entryId_not_in: [ID!]
  entryId_lt: ID
  entryId_lte: ID
  entryId_gt: ID
  entryId_gte: ID
  entryId_contains: ID
  entryId_not_contains: ID
  entryId_starts_with: ID
  entryId_not_starts_with: ID
  entryId_ends_with: ID
  entryId_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateInput {
  entryId: ID
  x: Int
  y: Int
  exhibition: ExhibitionUpdateOneRequiredWithoutRoomsInput
  placements: PlacementUpdateManyWithoutRoomInput
}

input RoomUpdateManyDataInput {
  entryId: ID
  x: Int
  y: Int
}

input RoomUpdateManyMutationInput {
  entryId: ID
  x: Int
  y: Int
}

input RoomUpdateManyWithoutExhibitionInput {
  create: [RoomCreateWithoutExhibitionInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutExhibitionInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutExhibitionInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateOneRequiredWithoutPlacementsInput {
  create: RoomCreateWithoutPlacementsInput
  update: RoomUpdateWithoutPlacementsDataInput
  upsert: RoomUpsertWithoutPlacementsInput
  connect: RoomWhereUniqueInput
}

input RoomUpdateWithoutExhibitionDataInput {
  entryId: ID
  x: Int
  y: Int
  placements: PlacementUpdateManyWithoutRoomInput
}

input RoomUpdateWithoutPlacementsDataInput {
  entryId: ID
  x: Int
  y: Int
  exhibition: ExhibitionUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateWithWhereUniqueWithoutExhibitionInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutExhibitionDataInput!
}

input RoomUpsertWithoutPlacementsInput {
  update: RoomUpdateWithoutPlacementsDataInput!
  create: RoomCreateWithoutPlacementsInput!
}

input RoomUpsertWithWhereUniqueWithoutExhibitionInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutExhibitionDataInput!
  create: RoomCreateWithoutExhibitionInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  entryId: ID
  entryId_not: ID
  entryId_in: [ID!]
  entryId_not_in: [ID!]
  entryId_lt: ID
  entryId_lte: ID
  entryId_gt: ID
  entryId_gte: ID
  entryId_contains: ID
  entryId_not_contains: ID
  entryId_starts_with: ID
  entryId_not_starts_with: ID
  entryId_ends_with: ID
  entryId_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  exhibition: ExhibitionWhereInput
  placements_every: PlacementWhereInput
  placements_some: PlacementWhereInput
  placements_none: PlacementWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
  entryId: ID
}

type Show {
  id: ID!
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  exhibition: Exhibition!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ShowConnection {
  pageInfo: PageInfo!
  edges: [ShowEdge]!
  aggregate: AggregateShow!
}

input ShowCreateInput {
  id: ID
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  exhibition: ExhibitionCreateOneWithoutShowsInput!
}

input ShowCreateManyWithoutExhibitionInput {
  create: [ShowCreateWithoutExhibitionInput!]
  connect: [ShowWhereUniqueInput!]
}

input ShowCreateWithoutExhibitionInput {
  id: ID
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
}

type ShowEdge {
  node: Show!
  cursor: String!
}

enum ShowOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  opensAt_ASC
  opensAt_DESC
  closesAt_ASC
  closesAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ShowPreviousValues {
  id: ID!
  number: Int!
  opensAt: DateTime!
  closesAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ShowScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  opensAt: DateTime
  opensAt_not: DateTime
  opensAt_in: [DateTime!]
  opensAt_not_in: [DateTime!]
  opensAt_lt: DateTime
  opensAt_lte: DateTime
  opensAt_gt: DateTime
  opensAt_gte: DateTime
  closesAt: DateTime
  closesAt_not: DateTime
  closesAt_in: [DateTime!]
  closesAt_not_in: [DateTime!]
  closesAt_lt: DateTime
  closesAt_lte: DateTime
  closesAt_gt: DateTime
  closesAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ShowScalarWhereInput!]
  OR: [ShowScalarWhereInput!]
  NOT: [ShowScalarWhereInput!]
}

type ShowSubscriptionPayload {
  mutation: MutationType!
  node: Show
  updatedFields: [String!]
  previousValues: ShowPreviousValues
}

input ShowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShowWhereInput
  AND: [ShowSubscriptionWhereInput!]
  OR: [ShowSubscriptionWhereInput!]
  NOT: [ShowSubscriptionWhereInput!]
}

input ShowUpdateInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
  exhibition: ExhibitionUpdateOneRequiredWithoutShowsInput
}

input ShowUpdateManyDataInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
}

input ShowUpdateManyMutationInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
}

input ShowUpdateManyWithoutExhibitionInput {
  create: [ShowCreateWithoutExhibitionInput!]
  delete: [ShowWhereUniqueInput!]
  connect: [ShowWhereUniqueInput!]
  set: [ShowWhereUniqueInput!]
  disconnect: [ShowWhereUniqueInput!]
  update: [ShowUpdateWithWhereUniqueWithoutExhibitionInput!]
  upsert: [ShowUpsertWithWhereUniqueWithoutExhibitionInput!]
  deleteMany: [ShowScalarWhereInput!]
  updateMany: [ShowUpdateManyWithWhereNestedInput!]
}

input ShowUpdateManyWithWhereNestedInput {
  where: ShowScalarWhereInput!
  data: ShowUpdateManyDataInput!
}

input ShowUpdateWithoutExhibitionDataInput {
  number: Int
  opensAt: DateTime
  closesAt: DateTime
}

input ShowUpdateWithWhereUniqueWithoutExhibitionInput {
  where: ShowWhereUniqueInput!
  data: ShowUpdateWithoutExhibitionDataInput!
}

input ShowUpsertWithWhereUniqueWithoutExhibitionInput {
  where: ShowWhereUniqueInput!
  update: ShowUpdateWithoutExhibitionDataInput!
  create: ShowCreateWithoutExhibitionInput!
}

input ShowWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  opensAt: DateTime
  opensAt_not: DateTime
  opensAt_in: [DateTime!]
  opensAt_not_in: [DateTime!]
  opensAt_lt: DateTime
  opensAt_lte: DateTime
  opensAt_gt: DateTime
  opensAt_gte: DateTime
  closesAt: DateTime
  closesAt_not: DateTime
  closesAt_in: [DateTime!]
  closesAt_not_in: [DateTime!]
  closesAt_lt: DateTime
  closesAt_lte: DateTime
  closesAt_gt: DateTime
  closesAt_gte: DateTime
  exhibition: ExhibitionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ShowWhereInput!]
  OR: [ShowWhereInput!]
  NOT: [ShowWhereInput!]
}

input ShowWhereUniqueInput {
  id: ID
}

type Subscription {
  asset(where: AssetSubscriptionWhereInput): AssetSubscriptionPayload
  counterfactualToken(where: CounterfactualTokenSubscriptionWhereInput): CounterfactualTokenSubscriptionPayload
  entity(where: EntitySubscriptionWhereInput): EntitySubscriptionPayload
  exhibition(where: ExhibitionSubscriptionWhereInput): ExhibitionSubscriptionPayload
  placement(where: PlacementSubscriptionWhereInput): PlacementSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  show(where: ShowSubscriptionWhereInput): ShowSubscriptionPayload
  ticket(where: TicketSubscriptionWhereInput): TicketSubscriptionPayload
}

type Ticket {
  id: ID!
  owner: Entity!
  exhibition: Exhibition!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TicketConnection {
  pageInfo: PageInfo!
  edges: [TicketEdge]!
  aggregate: AggregateTicket!
}

input TicketCreateInput {
  id: ID
  owner: EntityCreateOneWithoutTicketsInput!
  exhibition: ExhibitionCreateOneWithoutTicketsInput!
}

input TicketCreateManyWithoutExhibitionInput {
  create: [TicketCreateWithoutExhibitionInput!]
  connect: [TicketWhereUniqueInput!]
}

input TicketCreateManyWithoutOwnerInput {
  create: [TicketCreateWithoutOwnerInput!]
  connect: [TicketWhereUniqueInput!]
}

input TicketCreateWithoutExhibitionInput {
  id: ID
  owner: EntityCreateOneWithoutTicketsInput!
}

input TicketCreateWithoutOwnerInput {
  id: ID
  exhibition: ExhibitionCreateOneWithoutTicketsInput!
}

type TicketEdge {
  node: Ticket!
  cursor: String!
}

enum TicketOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TicketPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TicketScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TicketScalarWhereInput!]
  OR: [TicketScalarWhereInput!]
  NOT: [TicketScalarWhereInput!]
}

type TicketSubscriptionPayload {
  mutation: MutationType!
  node: Ticket
  updatedFields: [String!]
  previousValues: TicketPreviousValues
}

input TicketSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TicketWhereInput
  AND: [TicketSubscriptionWhereInput!]
  OR: [TicketSubscriptionWhereInput!]
  NOT: [TicketSubscriptionWhereInput!]
}

input TicketUpdateInput {
  owner: EntityUpdateOneRequiredWithoutTicketsInput
  exhibition: ExhibitionUpdateOneRequiredWithoutTicketsInput
}

input TicketUpdateManyWithoutExhibitionInput {
  create: [TicketCreateWithoutExhibitionInput!]
  delete: [TicketWhereUniqueInput!]
  connect: [TicketWhereUniqueInput!]
  set: [TicketWhereUniqueInput!]
  disconnect: [TicketWhereUniqueInput!]
  update: [TicketUpdateWithWhereUniqueWithoutExhibitionInput!]
  upsert: [TicketUpsertWithWhereUniqueWithoutExhibitionInput!]
  deleteMany: [TicketScalarWhereInput!]
}

input TicketUpdateManyWithoutOwnerInput {
  create: [TicketCreateWithoutOwnerInput!]
  delete: [TicketWhereUniqueInput!]
  connect: [TicketWhereUniqueInput!]
  set: [TicketWhereUniqueInput!]
  disconnect: [TicketWhereUniqueInput!]
  update: [TicketUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [TicketUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [TicketScalarWhereInput!]
}

input TicketUpdateWithoutExhibitionDataInput {
  owner: EntityUpdateOneRequiredWithoutTicketsInput
}

input TicketUpdateWithoutOwnerDataInput {
  exhibition: ExhibitionUpdateOneRequiredWithoutTicketsInput
}

input TicketUpdateWithWhereUniqueWithoutExhibitionInput {
  where: TicketWhereUniqueInput!
  data: TicketUpdateWithoutExhibitionDataInput!
}

input TicketUpdateWithWhereUniqueWithoutOwnerInput {
  where: TicketWhereUniqueInput!
  data: TicketUpdateWithoutOwnerDataInput!
}

input TicketUpsertWithWhereUniqueWithoutExhibitionInput {
  where: TicketWhereUniqueInput!
  update: TicketUpdateWithoutExhibitionDataInput!
  create: TicketCreateWithoutExhibitionInput!
}

input TicketUpsertWithWhereUniqueWithoutOwnerInput {
  where: TicketWhereUniqueInput!
  update: TicketUpdateWithoutOwnerDataInput!
  create: TicketCreateWithoutOwnerInput!
}

input TicketWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: EntityWhereInput
  exhibition: ExhibitionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TicketWhereInput!]
  OR: [TicketWhereInput!]
  NOT: [TicketWhereInput!]
}

input TicketWhereUniqueInput {
  id: ID
}
